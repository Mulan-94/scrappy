{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to scrappy's documentation","text":"<p>Scrappy is a collection of tools used to generate Faraday spectra for various  independent lines of sight across an extragalactic source. At its tail end, Scrappy generates plots to be used with PolarVis, an interactive, web-based visualisation tool that displays RM-synthesis data products corresponding to individual lines-of-sight.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Requires Python 3.10 or more, running on a Linux (Ubuntu) machine. This has not yet been tested on Windows or other Unix environment.</p>"},{"location":"#installation","title":"Installation","text":"<p>Since this tool is not yet available on PyPi, installation is done by running</p> <pre><code># If using SSH\npip install git+git@github.com:Mulan-94/scrappy.git\n\n# If using HTTPS\npip install git+https://github.com/Mulan-94/scrappy.git\n</code></pre> <p>Another option is cloning scrappy to your local machine and then installing it</p> <pre><code># Select SSH or HTTPS clone appropriately\ngit clone git@github.com:Mulan-94/scrappy.git\n\n# Install scrappy in editable to keep up with the bleeding edge\npip install -e scrappy\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<p>Scrappy consists of a pipeline script, [<code>showrunner.sh</code>][./showrunner], which performs multiple steps to achieve this end goal. This bash script CAN and SHOULD be modified to suit one's needs. The general variables that can be tweaked are located in the <code>env-vars</code> file. To avail the files required for <code>showrunner.sh</code>, they should be initialised using the following command:</p> <pre><code>scrappy -i\n</code></pre> <p>When ready, the pipeline <code>showrunner.sh</code> is run as:</p> <pre><code>./showrunner.sh -run\n</code></pre> <p>Its help is accessible as: <code>./showrunner -h</code>. There is additionally an option to run the individual functions in the pipeline by themselves using the syntax <code>./showrunner.sh functionName</code>. For example to run the 'makeDirs' function:</p> <pre><code>./showrunner.sh makeDirs\n</code></pre> <p>Furthermore, the Scrappy package hosts other tools that perform some intermediate processing steps. The Scrappy package consists of multiple scripts, which can be viewed using</p> <pre><code>scrappy -h\n</code></pre> <p>All these scripts are in use within the <code>showrunner</code>. They are:</p> <ul> <li><code>sc-houdini</code>: to generate masks.</li> <li><code>sc-los</code>: to generate the independent lines-of-sight (LoS).</li> <li><code>sc-losrm</code>: to perform RM-synthesis + RM-CLEAN on the LoS generated by <code>sc-los</code>.</li> <li><code>sc-rmmap</code>: to generate, among other things, an RM map.</li> <li><code>sc-bokehplot</code>: to generate interactive plots for the LoS. These are for integration with PolarVis.</li> <li><code>sc-ifit</code>: a rudimentary script for fitting Taylor polynomials to Stokes \\(\\mathit{I}\\).</li> </ul> <p>Each of the scripts has a help text that is accessible via the <code>-h</code> flag. Please consult the help menu for more information on the parameters required to run the individual scripts. More information is also availed in their specific pages on this documentation.</p>"},{"location":"#help-menu","title":"Help Menu","text":"<p>The result of running Scrappy's help function is as follows.</p> <pre><code>usage: scrappy [-v] [-h] [-i] [-f] [-p]\n\noptions:\n  -v, --version     Show scrappy version number and exit\n  -h, --help        \n                    This is a collection of python scripts that perform some RM related\n                    tasks, and geared towards (but not limited to) generating files to be used\n                    with polarvis: https://github.com/Mulan-94/polarvis\n                    The following command line tools are available and help accesible via: sc-los -h\n                     sc-losrm -h\n                     sc-rmmap -h\n                     sc-bokehplot -h\n                     sc-ifit -h\n                     sc-beam-plot -h\n                     sc-houdini -h\n                     scrappy -h\n                     sc-depol -h\n\n  -i, --initialize  Set up files required to run the showrunner. It will not run without those files\n  -f, --force       Force overwrite of the files required for showrunner in case they \n                        already exist in the current directory.\n  -p, --pica        Initialise some pica files specifically\n</code></pre>"},{"location":"#addendum","title":"Addendum","text":"<p>This project began as a custom script for Pictor A field but can now support any field provided a source mask is given. Parts of the RM-synthesis tools availed in this script evolved from those by Lerato Baidoo @sebokolodi and have been modified to suit our needs.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v010","title":"V0.1.0","text":"<ul> <li>Initial release of scrappy</li> </ul>"},{"location":"sc-beam-plot/","title":"sc-beam-plot","text":""},{"location":"sc-beam-plot/#introduction","title":"Introduction","text":"<p>Some sub-band images generated during multi-frequency imaging may become irrevocably unusable because of corruption  by RFI or the PSF. Consequently, such images are excluded from spectropolarimetric analysis. Since <code>WSClean</code> assigns a weight to each of the sub-band images -- where the better ones have more weight -- such images end up with lower weights. Sc-beam-plot excludes sub-band images whose weight is below a certain threshold. When it is impossible to reconstruct an image, its beam size may also be set to zero; such images are also excluded.</p> <p>As a diagnostic, sc-beam-plot generates a plot showing beam dimensions read from the <code>BMAJ &amp; BMIN</code> FITS header keywords before and after \"valid\" images are selected; these are stored in <code>00-beam_vs_freq.png</code> and <code>selected_beam_vs_freq.png</code>, respectively. This way, strange beam variations can easily be identified and further action taken. This tool also generates other <code>*.txt</code> outputs that are used within other tools in Scrappy. These are described in the next section.</p>"},{"location":"sc-beam-plot/#outputs","title":"Outputs","text":"Output Description <code>00-beams.npz</code> Contains beam dimensions in radians as a NumPy pickle file. <code>00-beam_vs_freq.png</code> Figure with all the images' (selected + unselected) beam dimensions. <code>beam-dims.txt</code> Contains the LARGEST beam size found amongst the selected images. <code>frequencies.txt</code> Frequencies of the selected sub-band images. <code>not-selected-channels.txt</code> Contains channel numbers (<code>WSClean</code> syntax) of the excluded images. <code>orig-wsums.txt</code> Contains weights of all the input images. <code>selected_beam_vs_freq.png</code> Figure showing the excluded channels. <code>selected-channels.txt</code> Contains channel numbers of the selected sub-band images. <code>selected-freq-images.txt</code> Contains names of the selected images. <code>wsums.txt</code> Weights of the selected images."},{"location":"sc-beam-plot/#help-menu","title":"Help Menu","text":"<pre><code>usage: sc-beam-plot [-h] [-o] [-search SEARCH] [-t] [-sc SEL] [-as] [-pre PREFIX] [-ec EXCLUDE]\n\npositional arguments:\n                        Directory where to find the input images\n\noptions:\n  -h, --help            show this help message and exit\n  -o , --output         Directory where to dump outputs. Default is current directory.\n  -search SEARCH, --search SEARCH\n                        Regex of what string to search in the directory\n  -t , --threshold      Channels with WSUM/WSUM.max() below this value will be excluded. Only used if -s is active\n  -sc SEL, --select-channels SEL\n                        Custom channel selections. This can be a file containing those channels, or a comma separated list e.g. '0,1,2,3'\n  -as, --auto-select    Try and suggest valid channels for selection. Use in conjuction with '-t'.\n  -pre PREFIX, --prefix PREFIX\n                        Prefix to append on the output images\n  -ec EXCLUDE, --exclude-channels EXCLUDE\n                        Channels to be excluded during autoselection. This can be a file containing those channels, or a comma separated list e.g. '0,1,2,3'.\n</code></pre>"},{"location":"sc-bokehplot/","title":"sc-bokehplot","text":""},{"location":"sc-bokehplot/#introduction","title":"Introduction","text":"<p>This tool takes in the per-LoS pickle files generated by sc-los-rm as its inputs and generates each of their corresponding interactive plots. Hence, before using this tool, one first must run the following tools in order:</p> <ol> <li>sc-los</li> <li>sc-los-rm</li> </ol> <p>Interactivity is achieved using the Bokeh Python visualisation library which is an automatic dependency of Scrappy. The plots to be generated by default currently are specified in the <code>bk_plots.yml</code> file, which is automatically availed when scrappy is initialised (see Getting started).</p>"},{"location":"sc-bokehplot/#outputs","title":"Outputs","text":"<p>Because <code>sc-bokehplot</code> is run in conjunction with <code>sc-los</code> and <code>sc-los-rm</code>, its outputs are stored the output directory containing the <code>sc-los</code> outputs, whose default output directory name is <code>scrap-outputs</code>. The yielded files are not regular <code>*.(png|jpg|svg)</code> files, rather they are <code>*.html</code> files which are viewed using a web-browser, and not a normal image viewer. As such, they offer the interactivity availed by a normal web-page.</p> <p>For example with a typical run using showrunner, the output appears like:</p> <pre><code>\n\u251c\u2500\u2500 scrap-outputs              # Outputs from Los data generator\n\u2502   \u251c\u2500\u2500 bokeh-plots            # Interactive plots generated by sc-bokeh-plots from sc-los-rm\n|       \u251c\u2500\u2500 reg_1.html\n|       \u251c\u2500\u2500 reg_2.html\n|       \u251c\u2500\u2500 ...\n|       \u251c\u2500\u2500 reg_n.html\n\u2502   \u251c\u2500\u2500 los-data              \n\u2502   \u251c\u2500\u2500 los-rm-data           \n\u2502   \u251c\u2500\u2500 los-rm-data-plots     \n\n</code></pre>"},{"location":"sc-bokehplot/#help-menu","title":"Help Menu","text":"<p>The help menu is accessible using</p> <pre><code>sc-bokehplot -h\n</code></pre> <p>which gives the following output</p> <pre><code>usage: \nExample\n\noptions:\n  -h, --help            show this help message and exit\n  -id I_DIRS [I_DIRS ...]\n                        Input directories where the LoS data is contained\n  --yaml YAMLS [YAMLS ...]\n                        Yaml file containing the plots to be plotted.\n  -od ODIR, --output-dir ODIR\n                        Where to dump outputs\n\n</code></pre>"},{"location":"sc-depol/","title":"sc-depol","text":""},{"location":"sc-depol/#introduction","title":"Introduction","text":"<p>This is not fully-fledged Python script. It is a simple shim availed to create a depolarization ratio map.</p> <p>The depolarization ratio is the ratio of fractional polarisation at a shorter wavelength, to that at a longer wavelength. The fractional polarisation, \\(P\\),  is defined using Stokes \\(\\mathit{I, Q, U}\\)  terms as:</p> \\[ \\begin{equation*} P = \\frac{\\sqrt{Q^{2} + U^{2}}}{\\mathit{I}} \\end{equation*} \\] <p>Given fractional polarization at different frequencies, \\(\\nu_{max}\\) and \\(\\nu_{min}\\), the depolarization ratio is given as:</p> \\[ \\begin{equation*} \\text{Depolarisation ratio}=\\frac{P\\text{ at }\\nu_{max}}{P\\text{ at }\\nu_{min}} \\end{equation*} \\]"},{"location":"sc-depol/#docstring-documentation","title":"Docstring Documentation","text":"<p>Calculate the depolarization ratio</p>"},{"location":"sc-depol/#src.rmsynthesis.rmmap_x2.depolarisation_ratio--parameters","title":"Parameters","text":"<p>(i|q|u)data: np.ndarray     Data cubes containing the stokes e_file: str     Name of the file containing errors. This is found in the file generated     from scrappy's 'sc-los' tool and is a numpy pickle file. mask: str     Name of mask to use while calculating depolarisation ratio output: str     Name of output depolarisation ratio map        </p>"},{"location":"sc-depol/#src.rmsynthesis.rmmap_x2.depolarisation_ratio--returns","title":"Returns","text":"<p>Maps of depolarization ratio and its error</p> Source code in <code>src/rmsynthesis/rmmap_x2.py</code> <pre><code>def depolarisation_ratio(idata, qdata, udata, e_file, mask=None, output=\"depol-map\"):\n    \"\"\"\n    Calculate the depolarization ratio\n\n    Parameters\n    ----------\n    (i|q|u)data: np.ndarray\n        Data cubes containing the stokes\n    e_file: str\n        Name of the file containing errors. This is found in the file generated\n        from scrappy's 'sc-los' tool and is a numpy pickle file.\n    mask: str\n        Name of mask to use while calculating depolarisation ratio\n    output: str\n        Name of output depolarisation ratio map        \n\n    Returns\n    -------\n    Maps of depolarization ratio and its error\n\n    \"\"\"\n\n    def depolzn_err(fp_lo, fer_lo, fp_hi, fer_hi):\n        return np.sqrt(np.square(fer_lo/fp_lo) + np.square(fer_hi/fp_hi))\n\n    def read_npz(fname):\n        return dict(np.load(fname))\n\n    ihdr = fits.getheader(idata)\n    idata = fits.getdata(idata).squeeze()\n    qdata = fits.getdata(qdata).squeeze()\n    udata = fits.getdata(udata).squeeze()\n\n    sel = [0,-1]\n\n    npz = read_npz(e_file)\n    ierr, qerr, uerr = npz[\"I_err\"][sel], npz[\"Q_err\"][sel], npz[\"U_err\"][sel]\n\n    idata, qdata, udata = idata[sel], qdata[sel], udata[sel]\n\n    if mask:\n        mask = fits.getdata(mask).squeeze()\n        idata = np.ma.masked_equal(idata*mask, 0).filled()\n        qdata = np.ma.masked_equal(qdata*mask, 0).filled()\n        udata = np.ma.masked_equal(udata*mask, 0).filled()\n\n    fpol = frac_polzn(idata, qdata, udata)\n\n\n\n    fperr_lo = frac_polzn_error(idata[0], qdata[0], udata[0], ierr[0], qerr[0], uerr[0])\n    fperr_hi = frac_polzn_error(idata[-1], qdata[-1], udata[-1], ierr[-1], qerr[-1], uerr[-1])\n\n\n    fp_lo, fp_hi = fpol[0], fpol[-1]    \n\n    depoln = fp_lo / fp_hi\n    depoln_err = depolzn_err(fp_lo, fperr_lo, fp_hi, fperr_hi)\n    depoln_err_ratio = depoln_err/depoln\n\n\n    depol_hdr = modify_fits_header(ihdr, ctype='depol', unit='unit')\n\n    #depolarization\n    fits.writeto(output+\".fits\", depoln, depol_hdr,\n        overwrite=True)\n\n    #depolarization\n    fits.writeto(output+\"-err.fits\", depoln_err, depol_hdr,\n        overwrite=True)\n\n    fits.writeto(output+\"-err-ratio.fits\", depoln_err_ratio, depol_hdr,\n        overwrite=True)\n\n    # write out fpol error at the highest freq (shortest wavelength)\n    fperr_hdr = modify_fits_header(ihdr, ctype='fpol_err', unit='unit')\n    fits.writeto(output+\"-fpol-err.fits\", fperr_hi, fperr_hdr,\n        overwrite=True)\n\n\n    snitch.info(\"Depolarization maps ready\")\n    return\n</code></pre>"},{"location":"sc-houdini/","title":"sc-houdini","text":""},{"location":"sc-houdini/#introduction","title":"Introduction","text":"<p>This tool creates a simple FITS mask given an input image and thresholds containing the values that should not be masked out. <code>Sc-houdini</code> also accepts region files specifying a region which its efforts should be concentrated within (see DS9 region files). </p>"},{"location":"sc-houdini/#outputs","title":"Outputs","text":"<p>Sc-houdini outputs:</p> <ul> <li>A FITS image mask</li> <li>A corresponding <code>*.png</code> file showing how the mask appears for quick mask inspection (this is sometimes buggy and is being investigated).</li> </ul> <p>With a typical run using showrunner, the output is stored in the <code>masks</code> directory and will appear like:</p> <pre><code>\n\u251c\u2500\u2500 masks                 # Location of the generated FITS masks\n|   \u251c\u2500\u2500 *.fits \n|   \u251c\u2500\u2500 *.png\n</code></pre>"},{"location":"sc-houdini/#help-menu","title":"Help Menu","text":"<p>The help menu is available using the command:</p> <pre><code>sc-houdini -h\n</code></pre> <p>which results in the output below. However, as the tool is under active development, the help menu may change in the future and should be checked before use using the help command after installation.</p> <pre><code>usage: sc-houdini [-h] [-o  [...]] [-above] [-below] [-rb  [...]] [-er] iname\n\npositional arguments:\n  iname                 Input image from which to generate mask\n\noptions:\n  -h, --help            show this help message and exit\n  -o  [ ...], --outname  [ ...]\n                        Where to dump the output(s). We can iterate over multiple reg files. See '-rb'\n  -above , --above      Include everything above this value. ie. &gt; above. Aka the lower limit\n  -below , --below      Include everything below this value. i.e &lt; below. Aka the upper limit\n  -rb  [ ...], --region-bound  [ ...]\n                        DS9 region file(s) within which to make our mask\n  -er , --exclude-region \n                        DS9 region file(s) containing the regions that should be excluded\n</code></pre>"},{"location":"sc-ifit/","title":"sc-ifit","text":""},{"location":"sc-ifit/#introduction","title":"Introduction","text":"<p>This fits a simple taylor polynomial on Stokes \\(\\mathit{I}\\) cube, generating a model \\(\\mathit{I}\\).</p>"},{"location":"sc-ifit/#help-menu","title":"Help Menu","text":"<p>The help menu is available using the command:</p> <pre><code>sc-ifit -h\n</code></pre> <p>which results in the output below. However, as the tool is under active development, the help menu may change in the future and should be checked before use using the help command after installation.</p> <pre><code>usage: sc-ifit [-h] [-mask MASK] [-ex EXCLUDE] [-u] [-deg DEG] [-o ODIR] cube freqs\n\nFit a simple taylor polynomial on Stokes I cube, generating a model I\n\npositional arguments:\n  cube                  Name of the input I cube to be modelled\n  freqs                 Text file containing respective frequencies. The freqs should be in Hz\n\noptions:\n  -h, --help            show this help message and exit\n  -mask MASK, --mask-name MASK\n                        Region within which to perform fits. This is a FITS MASK\n  -ex EXCLUDE, --exclude-channels EXCLUDE\n                        Channels that should be excluded while fitting the image cube. This should be a text file containing those channel numbers. Data corresponding to the specified channels will\n                        be set to zero.\n  -u, --unstack         Unstack the output model cube as single channelised images. If -ex was specified those channels will also be excluded.\n  -deg DEG, --degree DEG\n                        Degree of the taylor polynimial to be fitted.\n  -o ODIR, --output-dir ODIR\n                        Directory where to dump the output files.\n</code></pre>"},{"location":"sc-los/","title":"sc-los","text":""},{"location":"sc-los/#introduction","title":"Introduction","text":"<p>Autogenerate lines-of-sight and their corresponding \\(\\mathit{I, Q, U}\\) data and their derivatives.</p>"},{"location":"sc-los/#outputs","title":"Outputs","text":"<p>Sc-los generates the following general outputs:</p> <ul> <li>A region file containing the selected lines of sight.</li> <li>Plot showing locations of the 'valid' regions across the source</li> <li><code>NumPy</code> pickle files for each LoS containing its Stokes data.</li> </ul> <p>Each pickle file (with the file extension <code>*.npz</code>) stores the data in a N-dimensional array, where N is the number of available channels. Each file contains the following keys:</p> Key Description <code>I</code> I data for that LoS <code>Q</code> Q data for that LoS <code>U</code> U data for that LoS <code>i_mfs_noise</code> Noise from the reference I MFS image (same for all channels) <code>q_mfs_noise</code> Noise from the reference I MFS image (same for all channels) <code>u_mfs_noise</code> Noise from the reference I MFS image (same for all channels) <code>I_err</code> RMS noise extracted from a specific region in across the I spectrum <code>Q_err</code> RMS noise extracted from a specific region in across the Q spectrum <code>U_err</code> RMS noise extracted from a specific region in across the U spectrum <code>lpol</code> Linear polarised intensity per-channel <code>lpol_err</code> Linear polarised intensity error per-channel <code>fpol</code> Fractional polarisation per-channel <code>fpol_err</code> Fractional polarisation error per-channel <code>pangle</code> Polarisation angle per-channel <code>pangle_err</code> Polarisation angle error per-channel <code>mask</code> Mask boolean values. They are true (masked) where data is not sensible <code>freqs</code> Frequencies per-channel <p>As an example with a typical run using showrunner, the output appears like:</p> <pre><code>\n\u251c\u2500\u2500 scrap-outputs                                             # Outputs from Los data generators\n\u2502   \u251c\u2500\u2500 los-data                                              # LoS data outputs generated by sc-los\n|   |   \u251c\u2500\u2500 reg_1.npz\n|   |   \u251c\u2500\u2500 reg_1.npz\n|   |   \u251c\u2500\u2500 ...\n|   |   \u251c\u2500\u2500 reg_n.npz\n|   |\u2500\u2500 regions                                               # Contains all the region files generated during a run\n|   |   \u251c\u2500\u2500 regions-size-3-default.reg                        # All regions fitting within the specified mask region\n|   |   \u251c\u2500\u2500 regions-size-3-default.png                        # An illustration of the locations in regions-size-3-default.reg\n|   |   \u251c\u2500\u2500 regions-size-3-default-valid-candidates.reg       # Selected regions during the first pass of sc-los\n|   |   \u251c\u2500\u2500 regions-size-3-default-valid-candidates.png       # An illustration of the locations in regions-size-3-default-valid-candidates.reg\n|   |   \u251c\u2500\u2500 beacons.reg                                       # A copy of regions-valid.reg for PolarVis\n|   |   \u251c\u2500\u2500 noise-region.reg                                  # Region selected for RMS noise extraction\n|   |   \u251c\u2500\u2500 regions-valid.reg                                 # Region file with positions of the 'valid' lines-of-sight\n|   |   \u251c\u2500\u2500 regions-valid.png                                 # Figure showing the regions in regions-valid.reg across the source\n\n\n</code></pre> <p>The final and most important region file is <code>regions-valid.reg</code> (also called <code>beacons.reg</code>).</p>"},{"location":"sc-los/#help-menu","title":"Help Menu","text":"<p>The help menu is available using the command:</p> <pre><code>sc-los -h\n</code></pre> <p>which results in the output below. However, as the tool is under active development, the help menu may change in the future and should be checked before use using the help command after installation.</p> <pre><code>usage: sc-los [-h] [-nri NOISE_REF] [-todo] [--noverwrite] [-o] [-t] [-j] [--debug] [-ro] [-mrn] [-rf] [-rs] [-m] [-lo] [-idir IMAGE_DIR | -cubes CUBES CUBES CUBES] [-freqs] [-ref-image WCS_REF]\n              [-nrf NRFILE] [-mft] [-psnr] [-po] [--plot-grid] [-piqu] [-pfp] [-plp] [--ymax] [--ymin] [--xmax] [--xmin] [-p [...]] [-ps [...]]\n\n________________________________________________________________________________\n\n Description\n\n Generate I, Q and U data for various LoS from image cubes.\n\n This script uses the total intesity MFS image to determine regions\n of the source with enough SNR and selects those as the lines of sight.\n For now, this is tuned specifically for Pictor A, but it may be\n extended and revised in the future.\n\n The following could be generated from this script:\n\n . 1. Region file containing the selected lines of sight\n . 2. Plot showing locations of the regions on the source\n . 3. Pickle files containing the following keys for the data:\n\n .   - I      - Q     - U\n .   - i_mfs_noise    - q_mfs_noise   - u_mfs_noise\n .   - I_err    - Q_err   - U_err\n .   - lpol     - lpol_err\n .   - fpol     - fpol_err\n .   - pangle   - pangle_err\n .   - mask     - freqs\n . i.e for a single line of sight. Each LoS contains data for all\n . the available channels\n .\n . 4. Optionaly, generate plots for fractional polarisation vs\n lambda squared for each LoS\n\n________________________________________________________________________________\n\noptions:\n  -h, --help            show this help message and exit\n  -todo , --todo        A string containing to do items. Specify using: (r): generate regions, (l): generate LOS data, (p): generate plots. Default is 'rl'\n\nOptions:\n  -nri NOISE_REF, --noise-ref-image NOISE_REF\n                        The total intensity image used to get the global noise reference.\n\nGeneral arguments:\n  --noverwrite          Do not ovewrite everything along the way. Default is overwrite\n  -o , -odir , --output-dir \n                        where to dump output\n  -t , --threshold      If SNR below which data will not be considered. Default is 3\n  -j , --nworkers       How many workers to use for processing\n  --debug               Disble parallel processing and enables sequential mode.\n\nRegion generation arguments:\n  -ro, --regions-only   Only generate the region files. This requires the following options:   --ref-image --mask --region-size \n  -mrn , --minimum-region-noise \n                        Specific noise floor to generate the regions.\n  -rf , --region-file   An input region file. Otherwise, one will be auto-generated. Genereated regions will be stored here\n  -rs , --region-size   Create regions of this circle radius and perform analyses on them. If you want to set the data threshold, please use --threshold.\n  -m , --mask           Mask containing the area where LoS should be restricted. This can be a FITS file or a region file (*.reg). It's REQUIRED for automatically making regions.\n\nLoS Data generation arguments:\n  -lo, --los-only       Only generate the line of sight data files. The following options should be specified:   --idir/--cubes --ref-image --mask/--region-file --noise-ref-image --noise-\n                        ref-file \n  -idir IMAGE_DIR, --image_dir IMAGE_DIR\n                        Where the channelised I, Q and U images are\n  -cubes CUBES CUBES CUBES, --cubes CUBES CUBES CUBES\n                        The I, Q, U image cubes (in this specific order) to be used. This will require specification of --freq-file\n  -freqs , --freq-file \n                        Text file containing frequencies to be used. This is only active when the input FITS images are cubes and is particularly useful when the frequencies of images that form the\n                        cube do not increase monotonically.\n  -ref-image WCS_REF, --ref-image WCS_REF\n                        The reference image that will be used to generate the default region file. Must be the stokes I MFS image. This image will also be used to get the reference WCS for region\n                        file generation.\n  -nrf NRFILE, --noise-region-file NRFILE\n                        A region file containing region to be used as the noise reference.\n  -mft , --minimum-flag-threshold \n                        Fraction of flags above which lines of sight should be ignored. Can be useful if you want to plot all the generated LOS. Otherwise, they will be filtered out. The simple\n                        filter is that where values of fractional polarisation i are &gt;1 or &lt;0, this data is 'flagged'. behaviour: flag size &gt; 0.7 of total data is flagged, ingore. Max is 1, min is\n                        &gt;0. Default 0.7\n  -psnr, --use-polzd-snr\n                        Use to elect use of polarised SNR to determine valid LoS. Default S/N used is total intensity: rms noise\n\nPlotting Arguments:\n  -po, --plots-only     Only do plots\n  --plot-grid           Enable to make gridded plots\n  -piqu, --plot-iqu     Plot Q and U values\n  -pfp, --plot-frac-pol\n                        Plot Fractional polarization\n  -plp, --plot-linear-pol\n                        Plot linear polarization power\n  --ymax                Y axis max limit\n  --ymin                Y axis min limit\n  --xmax                Y axis max limit\n  --xmin                Y axis min limit\n  -p [ ...], --plot [ ...]\n                        Make plots for these region sizes manually. These will be linearly scaled\n  -ps [ ...], --plot-scales [ ...]\n                        Scales for the plots. Can be a space separated list of different scales. Options are linear or log.\n</code></pre>"},{"location":"sc-losrm/","title":"sc-losrm","text":""},{"location":"sc-losrm/#introduction","title":"Introduction","text":"<p>Perform RM-Synthesis on the line-of-sight data generated by <code>sc-los</code>. As such, <code>sc-los</code> must be run first. </p> <p>In addition to the per-LoS RM-synthesis data, this script also generates static diagnostic plots.</p>"},{"location":"sc-losrm/#outputs","title":"Outputs","text":"<pre><code>\n\u251c\u2500\u2500 scrap-outputs                   # Outputs from sc-los\n|   \u251c\u2500\u2500 los-data \n\u2502   \u251c\u2500\u2500 los-rm-data                 # LoS data outputs generated by sc-losrm\n|   |   \u251c\u2500\u2500 reg_1.npz\n|   |   \u251c\u2500\u2500 reg_2.npz\n|   |   \u251c\u2500\u2500 ...\n|   |   \u251c\u2500\u2500 reg_n.npz\n\u2502   \u251c\u2500\u2500 los-rm-data-plots           # LoS data static plots generated.\n|   |   \u251c\u2500\u2500 reg_1.png\n|   |   \u251c\u2500\u2500 reg_2.png\n|   |   \u251c\u2500\u2500 ...\n|   |   \u251c\u2500\u2500 reg_n.png\n\n</code></pre>"},{"location":"sc-losrm/#help-menu","title":"Help Menu","text":"<p>The help menu is available using the command:</p> <pre><code>sc-losrm -h\n</code></pre> <p>which results in the output below. However, as the tool is under active development, the help menu may change in the future and should be checked before use using the help command after installation.</p> <pre><code>usage: sc-losrm [-h] [-id DATA_DIRS [DATA_DIRS ...]] [-od OUTPUT_DIR] [-md MAX_FDEPTH] [--depth-step DEPTH_STEP] [-iters NITERS] [-np] [-nd] [-debug]\n\n________________________________________________________________________________\n\n Description\n\n This script takes in I, Q and U data and does the process\n of RM-SYNthesis and RM-CLEAN. It gives these outputs.\n\n Pickle files containing:\n . 1. The dirty FDF (Faraday Dispersion Funtion / Faraday spectrum)\n . 2. The cleaned FDF\n . 3. Faraday depths used\n\n These are the keys:\n . depths\n . fdirty\n . fclean\n . rmtf\n\n Plots of:\n . 4. The dirty and clean FDF and position angle vs wavelength sq and its\n linear squares fit\n . 5. The DATAs RMSF\n\n________________________________________________________________________________\n\noptions:\n  -h, --help            show this help message and exit\n  -id DATA_DIRS [DATA_DIRS ...], --input-dir DATA_DIRS [DATA_DIRS ...]\n                        Directory containing the various LoS data files\n  -od OUTPUT_DIR, --output-dir OUTPUT_DIR\n                        Where to dump the output plots if available\n  -md MAX_FDEPTH, --max-fdepth MAX_FDEPTH\n                        Maximum Faraday depth. Default is 500\n  --depth-step DEPTH_STEP\n                        Faraday depth step. Default is 10\n  -iters NITERS, --iters NITERS\n                        Number of RM clean iterations. Default is 1000\n  -np, --no-plot        plots for this data? Default is to plot\n  -nd, --no-derotate    Use this switch to NOT derotate the RMTF by the mean lambda squared.\n  -debug, --debug       Enable debug mode, will run in serial mode\n</code></pre>"},{"location":"sc-rmmap/","title":"sc-rmmap","text":""},{"location":"sc-rmmap/#introduction","title":"Introduction","text":""},{"location":"sc-rmmap/#output","title":"Output","text":""},{"location":"sc-rmmap/#help-menu","title":"Help Menu","text":"<pre><code>usage: sc-rmmap [-h] [-q QFITS] [-u UFITS] [-i IFITS] [-f FREQ] [-ncore NUMPROCESSOR] [-mask MASKFITS] [-o PREFIX] [-niters NITERS] [-md MAX_DEPTH] [--depth-step DEPTH_STEP] [-debug] [-snr SNR]\n                [-nd]\n\nPerforms linear least squares fitting to Q and U image.\n\noptions:\n  -h, --help            show this help message and exit\n  -q QFITS, --qcube QFITS\n                        Stokes Q cube (fits)\n  -u UFITS, --ucube UFITS\n                        Stokes U cube (fits)\n  -i IFITS, --icube IFITS\n                        Stokes I cube (fits)\n  -f FREQ, --freq FREQ  Frequency file (text)\n  -ncore NUMPROCESSOR, --ncore NUMPROCESSOR\n                        number of cores to use. Default 60.\n  -mask MASKFITS, --maskfits MASKFITS\n                        A mask image (fits)\n  -o PREFIX, --prefix PREFIX\n                        This is a prefix for output files.\n  -niters NITERS, --niters NITERS\n                        Number of clean iterations. Default 1000\n  -md MAX_DEPTH, --max-depth MAX_DEPTH\n                        Maximum Farady depth to fit for. Default 200\n  --depth-step DEPTH_STEP\n                        Depth stepping. Default 1\n  -debug, --debug       Enable debug mode, disable parallel processing\n  -snr SNR, --snr-threshold SNR\n                        Threshold to mask out data. Default is 10\n  -nd, --no-derotate    Use this switch to NOT derotate the RMTF by the mean lambda squared.\n</code></pre>"},{"location":"showrunner/","title":"showrunner.sh","text":"<p>A Bash-based pipeline taking in sub-band Stokes images and generates various spectrapolarimetric analysis and visualisation data products.</p> <p>This script is availed by initialising Scrappy in an output directory of choice as:</p> <pre><code>scrappy -i\n</code></pre> <p>There's also a <code>-f</code> option in case of the need to overwrite the initial files. Running the above command avails the following files:</p> <ul> <li><code>env-vars</code>      : containing pipeline-specific environment variables to be modified.</li> <li><code>bk_plots.yml</code>  : a configuration file for <code>sc-bokehplot</code>.</li> <li><code>showrunner.sh</code> : the pipeline script. </li> </ul> <p>Showrunner must be accorded execution permissions in order to run. This can be done by:</p> <pre><code>chmod +x showrunner.sh\n</code></pre> <p>There are three options for running <code>showrunner.sh</code>:</p> <ol> <li><code>./showrunner.sh -h</code>: to get the help menu.</li> <li><code>./showrunner.sh -run</code>: to run the entire pipeline.</li> </ol> <p>The third option is to run the individual functions in the pipeline by themselves using the syntax </p> <pre><code>./showrunner.sh functionName\n</code></pre> <p>For example to run the 'makeDirs' function:</p> <pre><code>./showrunner.sh makeDirs\n</code></pre>"},{"location":"showrunner/#setup","title":"Setup","text":"<p>This pipeline runs within the Linux shell environment. It has been tested using:</p> <ul> <li>Ubuntu 22.04</li> <li>Python 3.10</li> <li>Bash 5.1.16</li> </ul>"},{"location":"showrunner/#software","title":"Software","text":"<p>Disparate software -- both native to Linux and external Python software -- are used within this pipeline to achieve its goals. The following table summarises the software used (including scrappy).</p> Software Tool Description <code>montagePy</code> <code>fitsheader</code> Read FITS headers <code>owlcat</code> <code>fitstool.py</code> Creating Stokes cubes <code>spimple</code> <code>spimple-imconv</code> Image convolution to the same beam <code>spimple-spifit</code> Spectral index fitting <code>scrappy</code> <code>sc-beam-plot</code> Channel auto-selection and beam dimension plotting <code>sc-rmmap</code> Generate per-pixel RM maps among other things <code>sc-los</code> Generate independent LoS <code>sc-los-rm</code> Perform RM-synthesis on LoS from <code>scrappy</code> <code>sc-bokehplots</code> Generate interactive plots for the LoS <code>sc-houdini</code> Generate simple image masks given input images Native Linux <code>cp</code> Copy files and folders <code>ls</code> Listing files and folders <code>sed</code> For some text processing <code>mv</code> Moving and renaming files <code>rm</code> Deleting files and folders <code>rename(.ul)</code> Batch file renaming"},{"location":"showrunner/#output-directory-structure","title":"Output Directory Structure","text":"<p>After a complete run, this pipeline results in an output directory structure similar to the one below.</p> <pre><code>\u251c\u2500\u2500 masks                           # Location of the generated FITS masks\n\u251c\u2500\u2500 products\n\u2502   \u251c\u2500\u2500 conv-selection-cubes        # Location of the selected sub-band images' cubes convolved to the same resolution\n\u2502   \u251c\u2500\u2500 original-cubes              # Location of the full band images' cubes\n\u2502   \u251c\u2500\u2500 selection-cubes             # Location of selected images' cubes\n|   \u251c\u2500\u2500 scrap-outputs               # Outputs from Los data generators\n\u2502   \u2502   \u251c\u2500\u2500 bokeh-plots             # Interactive plots generated by sc-bokeh-plots from sc-los-rm\n\u2502   \u2502   \u251c\u2500\u2500 los-data                # LoS data outputs generated by sc-los\n\u2502   \u2502   \u251c\u2500\u2500 los-rm-data             # LoS data outputs generated by sc-los-rm\n\u2502   \u2502   \u251c\u2500\u2500 los-rm-data-plots       # Static plots generated by sc-los-rm\n\u2502   \u2502   \u2514\u2500\u2500 regions                 # Location of region files autoselected by sc-los\n\u2502   \u2514\u2500\u2500 spi-fitting                 # Location of the spectral index fitter outputs\n\u251c\u2500\u2500 relevant-images                 # Location of the selected images\n\u2514\u2500\u2500 relevant-images-conv            # Location of the singular sub-band images convolved to the same resolution\n</code></pre>"},{"location":"showrunner/#pipeline-flow-illustration","title":"Pipeline flow illustration","text":"<pre><code>graph TD\n    s0((Launch showrunner.sh)) --&gt; s1\n    subgraph Required steps\n        s1(Install python dependencies) --&gt; s2(Initialise directories)\n    end\n    s2 --&gt; s2b(Stack all sub-band images)\n    s2b --&gt; s2c[/All sub-bands cube/]\n\n    s2 --&gt; s3(Auto-select good sub-bands)\n    s3 -- Selected images --&gt; s3a(Stack selected sub-band images)\n    s3a --&gt;s3b[/Selected sub-bands cube/]\n\n    s3 -- Selected images --&gt; s4{Convolve before stacking?}\n    s4 -- Yes --&gt; s5a(Convolve individual sub-band images)\n    s5a --&gt; s5ao[/Convolved sub-band images/]\n    s5a --&gt; s5a1(Make image cube)\n    s4 -- No --&gt; s5b(Make image cube)\n    s5b --&gt; s5b1(Convolve image cube)\n    s5a1 --&gt; s5o[/Convolved image cube/]\n    s5b1 --&gt; s5o\n\n    s3 --&gt; s6(Make Source mask)\n    s6 -- source mask --&gt; s7(Make RM map and other maps)\n    s7 -- Fpol map --&gt; s8(Make Fpol mask)\n    s8 -- Fpol mask + (convolved individual or cube) image --&gt; s9(Generate LoS data)\n    s9 -- LoS data --&gt; s10(RM-synthesis on Los Data)\n    s10 --RM-synth Los Data --&gt; s11(Generate interactive plots)\n    s11 --&gt; s12(Generate depolarization maps)\n    subgraph optional steps\n        s12 --&gt; s13(Generate spectral index maps)\n    end\n    s13 --&gt; s14((End))\n\n</code></pre>"}]}